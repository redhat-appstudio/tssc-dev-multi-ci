# Fill in template values and set run local
# the env.template is copyed to the RHDH sample templates
# into env.sh and is filled in by the template expansion
export LOCAL_SHELL_RUN=true

source setup-local-dev-repos.sh

# optional set repo url and it will update this repo with the new image
# this means you need to pull after a build to be in sync

# Optionally update the gitops repo from build
# can be disabled if user does not have fork of the gitops
# test repos
OPTIONAL_REPO_UPDATE=$TEST_GITOPS_REPO

REQUIRED_ENV="MY_QUAY_USER "
REQUIRED_BINARY="tree "
rhtap/verify-deps-exist "$REQUIRED_ENV" "$REQUIRED_BINARY"
ERR=$?
echo "Dependency Error $1 = $ERR"
if [ $ERR != 0 ]; then
    echo "Fatal Error code for $1 = $ERR"
    exit $ERR
fi

# update the cloned repo with the contents it would have
# if it was generated by RHDH Templates

# RHTAP directory for local test
cp -r rhtap $BUILD/
# ENV with params
SETUP_ENV=$BUILD/rhtap/env.sh
cp rhtap/env.template.sh $SETUP_ENV
sed -i "s!\${{ values.image }}!$IMAGE_TO_BUILD!g" $SETUP_ENV
sed -i "s!\${{ values.dockerfile }}!Dockerfile!g" $SETUP_ENV
sed -i "s!\${{ values.buildContext }}!.!g" $SETUP_ENV
sed -i "s!\${{ values.repoURL }}!$OPTIONAL_REPO_UPDATE!g" $SETUP_ENV

source $SETUP_ENV

SIGNING_SECRET_ENV=$BUILD/rhtap/signing-secret-env.sh
if [ ! -f $SIGNING_SECRET_ENV ]; then
    # If the signing secret file doesn't exist already then generate one
    hack/create-signing-secret > $SIGNING_SECRET_ENV
fi
# When running in Jenkins the secret values will be read from credentials
source $SIGNING_SECRET_ENV

# change into the cloned repository to continue this
# assume tssc and other assets have been copied into the repo

cd $BUILD

COUNT=0

function run() {
    let "COUNT++"
    printf "\n"
    printf '=%.0s' {1..31}
    printf " %d " $COUNT
    printf '=%.0s' {1..32}

    # Set a env var to skip a step, for example:
    #   export SKIP_acs_image_scan=1
    STEP_NAME=$(basename $1 .sh)
    SKIP_VAR="SKIP_${STEP_NAME//-/_}"

    if [ "${!SKIP_VAR}" == "1" ]; then
        echo "Skipping $1"
    else
        bash $1
        ERR=$?
        echo "Error code for $1 = $ERR"
        printf '_%.0s' {1..64}
        printf "\n"
        if [ $ERR != 0 ]; then
            echo "Fatal Error code for $1 = $ERR"
            exit 1
        fi
    fi
}
rm -rf ./results

# See templates/build-pipeline-steps.sh.njk
source rhtap/build-pipeline-steps.sh

# cleanup
rm -rf roxctl
rm -rf roxctl_image_check_output.json roxctl_image_scan_output.json
rm -rf acs-deploy-check.json acs-image-check.json acs-image-scan.json
